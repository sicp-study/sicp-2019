#+TITLE: SICP 1.2 assignment
#+AUTHOR: Tristan de Cacqueray
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* The Elements of Programming
** Procedures and the Processes They Generate

- *Iteration process*: time: O(x), space O(1)
- *Recursion process*: time: O(x), space O(x)

Not to be confused by procedure, which can be define recursively an iterative process (at least in scheme).


*** Exercise 1.9
Evaluate two '+' procedures:
#+BEGIN_SRC scheme :tangle 1.9.txt
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))
(+ 4 5)
;; (inc (+ 3 5))
;; (inc (inc (+ 2 5)))
;; (inc (inc (inc (+ 1 5))))
;; (inc (inc (inc (inc (+ 0 5)))))
;; (inc (inc (inc (inc 5))))
;; (inc (inc (inc 6)))
;; (inc (inc 7))
;; (inc 8)
;; 9

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
(+ 4 5)
;; (+ 3 6)
;; (+ 2 7)
;; (+ 1 8)
;; 9
#+END_SRC

The first process is recursive while the second is iterative

*** Exercise 1.10
Study the following Ackermann's function implementation:

#+BEGIN_SRC scheme :tangle 1.10.txt
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
(A 1 10)
;; (A 0 (A 1 9))
;; (A 0 (A 0 (A 1 8))
;; (A 0 (A 0 (A 0 (A 1 7))))
;;  ...           (A 0 (A 1 1))
;;  ...           (A 0 2)
;;  ...           (4); then 8; then 16
;; -> 2**10 = 1024

(A 2 4)
;; (A 1 (A 2 3))
;; (A 1 (A 1 (A 2 2)))
;; (A 1 (A 1 (A 1 (A 2 1))))
;; (A 1 (A 1 (A 1 2)))
;; (A 1 (A 1 (2**2)))
;; (A 1 (2**4))
;; 2**16

 (A 3 3)
;; (A 2 (A 3 2))
;; (A 2 (A 2 (A 3 1)))
;; (A 2 (A 2 2))
;; (A 2 (A 1 (A 2 1)))
;; (A 2 (A 1 2))
;; (A 2 (A 0 (A 1 1)))
;; (A 2 (A 0 2))
;; (A 2 4)
;; 2**16


(define (f n) (A 0 n))
;; (f n) computes 2 * n

(define (g n) (A 1 n))
;; (g n) computes 2 ^ n

(define (h n) (A 2 n))
;; (h n) computes 2 ** (h (- n 1)) with h(0) = 1
(h 3)
#+END_SRC

Fun note, my python implementation failed at running (A 3 4). IIUC, mit-scheme optimize tail recursion.

*** Exercise 1.11
Write the following function using a recursive and iterative process:
f(n) = n if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n>3.

#+BEGIN_SRC scheme :tangle 1.11.scm
(define (f-recursive n)
   (if (< n 3)
       n
       (+ (f-recursive (- n 1))
          (* 2 (f-recursive (- n 2)))
          (* 3 (f-recursive (- n 3))))))

(define (f-iter a b c count)
   (if (< count 3)
       a
       (f-iter (+ a (* 2 b) (* 3 c))
               a
               b
               (- count 1))))
;; a = f(n - 1), starting at n=3, it's f(2) = 2
;; b = 2 * f(n - 2), starting at n=3, it's 2 * f(1) = 1
;; c = 3 * f(n - 3), starting at n=3, it's 3 * f(0) = 0
(define (f-iterative n)
  (if (< n 3) n (f-iter 2 1 0 n)))
#+END_SRC

Similarly to the iterative fibonacci implementation, we can store the state
of each f() result in different variables.

*** Exercise 1.12
A recursive process to compute pascal number:

#+BEGIN_SRC scheme :tangle 1.12.scm
(define (pascal-recurse row col)
  (cond ((= row 1) 1)
        ((= col 1) 1)
        ((= col row) 1)
        (else (+ (pascal-recurse row (- col 1))
                 (pascal-recurse (- row 1) (- col 1))))))
(define (pascal row col)
   (if (and (>= row 1) (>= col 1) (<= row col))
       (pascal-recurse row col)
       -1))
#+END_SRC

*** Exercise 1.13

This exercise feels really off-topic...
I had to look up what induction proof means and refresh some math identities:
- 2**n * 2**k = 2**(n + k)
- k * k**n = k**(n + 1)

Induction proof that: fib(n) = (fi^n - psi^n) / sqrt(5) with
- fi = (1 + sqrt(5) / 2)
- psi = (1 - sqrt(5) / 2)

Induction proof is 2 steps, first the base case needs to be proven,
then induction step proves the property hold for n+1.

#+BEGIN_SRC text
Base case:
fib(0) = (1 - 1) / sqrt(5) = 0
fib(1) = (fi - psi) / sqrt(5) = sqrt(5) / sqrt(5) = 1

Induction step:
fib(n) = fib(n - 2) + fib(n - 1)
       = (fi^(n-2) - psi^(n-2) + fi^(n-1) - psi^(n-1)) / sqrt(5)
       = ((fi^(n-2) + fi^(n-1)) - (psi^(n-2) + psi^(n-1))) / sqrt(5)
       = ((1 + fi) * fi^(n-2) - (1 + psi) * psi^(n-2)) / sqrt(5)
#+END_SRC

In section 1.2.2 we learn that fi^2 = 1 + fi, and the same seems true
for psi^2 = 1 + psi (to be proven i guess?)

#+BEGIN_SRC text
fib(n) = (fi^2 * fi^(n-2) - psi^2 * psi^(n-2)) / sqrt(5)
       = (fi^n - psi^n) / sqrt(5)
#+END_SRC

With that proof, we can say that fib(n) is close to fi^n / sqrt(5) because
psi^n is negligable.

*** Exercise 1.14
Evaluate the count-change procedure:

#+BEGIN_SRC scheme :tangle 1.14.scm
(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
(count-change 96)
#+END_SRC

[[./1.14.svg]]

count-change space grows is O(n) as the longest branch is the sum of pennies.
Time grows seems more complex to define. I added a counter to cc evaluation:

|  n | cc call |
|----+---------|
| 11 |      56 |
| 12 |      64 |
| 24 |     232 |
| 48 |    1416 |
| 96 |   13484 |

Thus time appears to be growing exponientally.

*** Exercice 1.15

(sine 12.15) recurse until the angle is less than 0.1
Each time, the angle is divided by 3, so sine is called 5 times.

If we triple the initial angle, then it only adds 1 more step, thus
the space grows is logarithmic.
Sine is a linear recursion, thus the time grows is also logarithmic.

*** Exercice 1.16
Even exponentiation can be re-written from:
(b ** (n / 2)) ** 2 = (b ** 2 ) ** (n / 2)
Which is similar to odd exponentiation: b ** (n - 1)

Using a counter named a, we can rewrite the fast exponentiation using an iterative process:
#+BEGIN_SRC scheme :tangle 1.16.scm
(define (even? n)
  (= (remainder n 2) 0))
(define (fast-expt-iter b n a)
  (cond ((= n 0) a)
        ((even? n) (fast-expt-iter (* b b) (/ n 2) a))
        (else (fast-expt-iter b (- n 1) (* a b)))))
(define (fast-expt-iterative b n)
  (fast-expt-iter b n 1))
#+END_SRC

*** Exercise 1.17

Using halve and double, fast-mult can be implemented such as:
a * b = 2 * a * b / 2   if b is even
a * b = a + (a * (b - 1)) if b is odd

#+BEGIN_SRC scheme :tangle 1.17.scm
(define (even? n)
  (= (remainder n 2) 0))
(define (double x) (+ x x))
(define (halve x) (/ x 2))
(define (fast-mult a b)
  (cond ((= b 0) 0)
        ((= b 1) a)
        ((even? b) (double (fast-mult a (halve b))))
        (else (+ a (fast-mult a (- b 1))))))
(fast-mult 3 5)
#+END_SRC

*** Exercise 1.18
Using a counter, fast-mult can be written for an interative process:
#+BEGIN_SRC scheme :tangle 1.18.scm
(define (fast-mult-iter a b counter)
  (cond ((= b 0) 0)
        ((= b 1) (+ counter a))
        ((even? b) (fast-mult-iter (double a) (halve b) counter))
        (else (fast-mult-iter a (- b 1) (+ counter a)))))
(define (fast-mult-iterative a b)
    (fast-mult-iter a b 0))
(fast-mult-iterative 5 9)
#+END_SRC

*** Exercise 1.19
"Tpq transforms the pair (a,b) according to a = bq + aq + ap and b = bp + aq. Show that if we apply such a transformation Tpq twice, the effect is the same as using a single transformation Tp'q' of the same form"

#+BEGIN_SRC text
Let's apply Tpq one more time:
a = (bp + aq) * q + (bq + aq + ap) * q + (bq + aq + ap) * p
a = bpq + aq^2 + bq^2 + aq^2 + apq + bqp + aqp + ap^2
a = b * (pq + q^2 + qp) + a * (pq + q^2 + qp) + a * (q^2 + p^2)

b = (bp + aq) * p + (bq + aq + ap) * q
b = bp^2 + aqp + bq^2 + aq^2 + apq
b = b * (p^2 + q^2) + a * (qp + q^2 + pq)

Thus Tp'q' is Tpq twice with:
p' = p^2 + q^2
q' = pq + q^2 + qp
#+END_SRC

#+BEGIN_SRC scheme :tangle 1.19.scm
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p) (* q q))
                   (+ (* p q) (* q q) (* q p))
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
#+END_SRC

This feels like magic :)

*** Exercise 1.20
Compare gcd execution with applicative-order and normal-order evaluation.
The question is how many time remainder is evaluated.
#+BEGIN_SRC scheme :tangle 1.20.scm
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+END_SRC

Evaluation of (gcd 206 40):
#+BEGIN_SRC text
(gcd 40 (remainder 206 40))
(gcd 6  (remainder 40 6))
(gcd 4  (remainder 6 4))
(gcd 2  (remainder 4 2))
(gcd 2  0)
#+END_SRC

Remainder is called 4th time with applicative-order evaluation.


With applicative order evaluation (using R for remainder):
(gcd 206 40)
#+BEGIN_SRC text
(gcd 40 (R 206 40))
  (if (R 206 40))
  (gcd (R 206 40) (R 40 (R 206 40)))
    (if (R 40 (R 206 40)))
    (gcd (R 40 (R 206 40)) (R (R 206 40) (R 40 (R 206 40))))
      (if (R (R 206 40) (R 40 (R 206 40))))
      (gcd (R (R 206 40) (R 40 (R 206 40))) (R (R 40 (R 206 40)) (R (R 206 40) (R 40 (R 206 40)))))
        (if (R (R 40 (R 206 40)) (R (R 206 40) (R 40 (R 206 40)))))
        (R (R 206 40) (R 40 (R 206 40)))
#+END_SRC

Counting the if evaluation and the final evaluation: 1 + 2 + 4 + 7 + 4 = 18 remainder evaluations
with normal-order.

*** Exercise 1.21
Test the smallest-divisor method with 199, 1999 and 19999:
#+BEGIN_SRC scheme
  (define (smallest-divisor n)
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((divides? test-divisor n) test-divisor)
            (else (find-divisor n (+ test-divisor 1)))))
    (define (divides? a b)
      (= (remainder b a) 0))
    (find-divisor n 2))

  (smallest-divisor 199)
  (smallest-divisor 1999)
  (smallest-divisor 19999)
#+END_SRC

199 and 1999 are primes. 1999 is 7 * 2857.

*** Exercise 1.22
Use (runtime) to measure prime test performance.
#+BEGIN_SRC scheme
  (define (search-for-primes n)
    (define (prime? n)
      (= n (smallest-divisor n)))

    (define (report-prime n elapsed-time)
      (newline)
      (display n)
      (display " *** ")
      (display elapsed-time))

    (define (search-for-primes-loop n start-time)
      (if (prime? n)
          (report-prime n (- (runtime) start-time))
          (search-for-primes-loop (+ n 1) (runtime))))

    (search-for-primes-loop n (runtime)))

  (search-for-primes 1e6)
  (search-for-primes 1e7)
  (search-for-primes 1e8)
  (search-for-primes 1e9)
  (search-for-primes 1e10)
#+END_SRC

1e6  took 0
1e7  took 0.01
1e8  took 0.02
1e9  took 0.059
1e10 took 0.17

Timing shows about *3 for each magnitude which seems to match the notion that programs
run in time proportional to the number of steps required for the computation.

*** Exercise 1.23
Improve smallest-divisor by skipping even numbers:
#+BEGIN_SRC scheme
  (define (smallest-divisor n)
    (define (next n)
      (if (= n 2)
          3
          (+ n 2)))
    (define (find-divisor n test-divisor)
      (cond ((> (square test-divisor) n) n)
            ((divides? test-divisor n) test-divisor)
            (else (find-divisor n (next test-divisor)))))
    (find-divisor n 2))
#+END_SRC
The search-for-primes now runs almost twice faster.

*** Exercise 1.24
Testing the fast-prime procedure:

#+BEGIN_SRC scheme
  (define (fast-prime? n times)
    (define (expmod base exp m)
      (cond ((= exp 0) 1)
            ((even? exp)
             (remainder (square (expmod base (/ exp 2) m))
                        m))
            (else
             (remainder (* base (expmod base (- exp 1) m))
                        m))))
    (define (fermat-test n)
      (define (try-it a)
        (= (expmod a n n) a))
      (try-it (+ 1 (random (- n 1)))))

    (cond ((= times 0) true)
          ((fermat-test n) (fast-prime? n (- times 1)))
          (else false)))

   (define (search-for-fast-primes n)
      (define (report-prime n elapsed-time)
        (newline)
        (display n)
        (display " *** ")
        (display elapsed-time))

      (define (search-for-primes-loop n start-time)
        (if (fast-prime? n 42)
            (report-prime n (- (runtime) start-time))
            (search-for-primes-loop (+ n 1) (runtime))))

      ;; (round->exact 1eX) returns an integer, required by the expmod procedure
      (search-for-primes-loop (round->exact n) (runtime)))
  (search-for-fast-primes 1e28)
#+END_SRC

I'm not sure how many time are we supposed to run the fermat test, using 42
yields very fast results, barely measurable by the runtime value.

| prime | runtime |
|-------+---------|
|  1e13 |   0.009 |
|  1e14 |    0.01 |
| 1e100 |    0.02 |
| 1e200 |    0.07 |

With larger numbers, the time grows doesn't seems logarithmic, and it's probably
because arithmetic is not constant for big numbers.

*** Exercise 1.25

The expmod doesn't compute the full exponent but it can use a procedure that
computes the remainders of smaller number. The method proposed by Alyssa is
correct but it will be much slower for large number prime test since arithmetic
on big numbers is slow, as observed in the previous exercise.

*** Exercise 1.26

Scheme will evaluate 2 times the expmod when doing (* (expmod) (expmod)) instead of
(square (expmod)). This makes the expmod do a tree recursion instead of a linear recursion.
The time grows is O(exp(expmodN)) = O(exp(log(N))) = O(N).

*** Exercise 1.27

Test carmichel numbers:
#+BEGIN_SRC scheme
  (define (carmichel? n)
    (define (test-loop a n)
      (cond ((and (< a n) (= (expmod a n n) a)) (test-loop (+ a 1) n))
            ((= a n) #t)
            (else #f)))
    (test-loop 1 n))
  (carmichel? 561)
  (carmichel? 1105)
  (carmichel? 1729)
  (carmichel? 2465)
  (carmichel? 2821)
  (carmichel? 6601)

  (define (find-carmichel max)
    (define (found-carmichel n)
      (write "Carmichel: ")
      (write n)
      (if (not (carmichel? n))
          (write " carmichel? test is wrong..."))
      (newline))
    (define (find-carmichel-loop n)
      (if (= n 1) (write "over"))
      (if (and (fast-prime? n (- n 1)) (not (prime? n))) (found-carmichel n))
      (find-carmichel-loop (- n 1)))
    (find-carmichel-loop max))
  (find-carmichel 1000)
#+END_SRC

I don't understand why the carmichel? test returns true for non carmichel number such as 89.
Also I'm not sure what "tests whether an is congruent to a modulo n" means.
I wrote a function to search for carmichel by comparing (prime?) and (fast-prime?), but then
the function sometime find 6 to be a carmichel number. I don't have enough time to investigate
these results...

*** Exercise 1.28

Miller-rabin test.

#+BEGIN_SRC scheme
  (define (miler-rabin-prime? n)
    (define (nontrivial-square n m)
      (cond ((= n 1) #f)
            ((= n (- m 1)) #f)
            (else (= (remainder (* n n) 1) 1))))

    (define (expmod base exp m)
      (cond ((= exp 0) 1)
            ((even? exp)
             (if (nontrivial-square base m)
                 0
                 (remainder (square (expmod base (/ exp 2) m))
                            m)))
            (else
             (remainder (* base (expmod base (- exp 1) m))
                        m))))
    (define (miler-rabin-test a n)
      (cond ((= a 0) #t)
            ((= (expmod a (- n 1) n) 1) (miler-rabin-test (- a 1) n))
            (else #f)))

    (miler-rabin-test (- n 1) n))

  (miler-rabin-prime? 6601)
  (miler-rabin-prime? 10007)
#+END_SRC

I'm not entirely sure about the implementation since
"a raised to the (n - 1)st power is congruent to 1 modulo n" is confusing.
Though the above miler-rabin-prime? isn't fooled by carmichel numbers.
